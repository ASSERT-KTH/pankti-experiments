<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Peer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.turn.ttorrent.common</a> &gt; <span class="el_source">Peer.java</span></div><h1>Peer.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2011-2012 Turn, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.turn.ttorrent.common;

import com.turn.ttorrent.Constants;
import org.slf4j.Logger;

import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;


/**
 * A basic BitTorrent peer.
 *
 * &lt;p&gt;
 * This class is meant to be a common base for the tracker and client, which
 * would presumably subclass it to extend its functionality and fields.
 * &lt;/p&gt;
 *
 * @author mpetazzoni
 */
public class Peer {

<span class="fc" id="L39">  private static final Logger logger = TorrentLoggerFactory.getLogger(Peer.class);</span>

  private final InetSocketAddress address;
  private final String hostId;

  private ByteBuffer peerId;
  private volatile String hexPeerId;
  private volatile String hexInfoHash;

  /**
   * Instantiate a new peer.
   *
   * @param address The peer's address, with port.
   */
  public Peer(InetSocketAddress address) {
<span class="fc" id="L54">    this(address, null);</span>
<span class="fc" id="L55">  }</span>

  /**
   * Instantiate a new peer.
   *
   * @param ip   The peer's IP address.
   * @param port The peer's port.
   */
  public Peer(String ip, int port) {
<span class="fc" id="L64">    this(new InetSocketAddress(ip, port), null);</span>
<span class="fc" id="L65">  }</span>

  /**
   * Instantiate a new peer.
   *
   * @param ip     The peer's IP address.
   * @param port   The peer's port.
   * @param peerId The byte-encoded peer ID.
   */
  public Peer(String ip, int port, ByteBuffer peerId) {
<span class="fc" id="L75">    this(new InetSocketAddress(ip, port), peerId);</span>
<span class="fc" id="L76">  }</span>

  /**
   * Instantiate a new peer.
   *
   * @param address The peer's address, with port.
   * @param peerId  The byte-encoded peer ID.
   */
<span class="fc" id="L84">  public Peer(InetSocketAddress address, ByteBuffer peerId) {</span>
<span class="fc" id="L85">    this.address = address;</span>
<span class="fc" id="L86">    this.hostId = String.format(&quot;%s:%d&quot;,</span>
<span class="fc" id="L87">            this.address.getAddress(),</span>
<span class="fc" id="L88">            this.address.getPort());</span>

<span class="fc" id="L90">    this.setPeerId(peerId);</span>
<span class="fc" id="L91">  }</span>

  /**
   * Tells whether this peer has a known peer ID yet or not.
   */
  public boolean hasPeerId() {
<span class="nc bnc" id="L97" title="All 2 branches missed.">    return this.peerId != null;</span>
  }

  /**
   * Returns the raw peer ID as a {@link ByteBuffer}.
   */
  public ByteBuffer getPeerId() {
<span class="fc" id="L104">    return this.peerId;</span>
  }

  public byte[] getPeerIdArray() {
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">    return peerId == null ? null : peerId.array();</span>
  }

  /**
   * Set a peer ID for this peer (usually during handshake).
   *
   * @param peerId The new peer ID for this peer.
   */
  public void setPeerId(ByteBuffer peerId) {
<span class="fc bfc" id="L117" title="All 2 branches covered.">    if (peerId != null) {</span>
<span class="fc" id="L118">      this.peerId = peerId;</span>
<span class="fc" id="L119">      this.hexPeerId = TorrentUtils.byteArrayToHexString(peerId.array());</span>
    } else {
<span class="fc" id="L121">      this.peerId = null;</span>
<span class="fc" id="L122">      this.hexPeerId = null;</span>
    }
<span class="fc" id="L124">  }</span>

  public String getStringPeerId() {
    try {
<span class="nc" id="L128">      return new String(peerId.array(), Constants.BYTE_ENCODING);</span>
<span class="nc" id="L129">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L130">      LoggerUtils.warnAndDebugDetails(logger, &quot;can not get peer id as string&quot;, e);</span>
    }
<span class="nc" id="L132">    return null;</span>
  }

  /**
   * Get the hexadecimal-encoded string representation of this peer's ID.
   */
  public String getHexPeerId() {
<span class="fc" id="L139">    return this.hexPeerId;</span>
  }

  /**
   * Get the shortened hexadecimal-encoded peer ID.
   */
  public String getShortHexPeerId() {
<span class="fc" id="L146">    return String.format(&quot;..%s&quot;,</span>
<span class="fc" id="L147">            this.hexPeerId.substring(this.hexPeerId.length() - 6).toUpperCase());</span>
  }

  /**
   * Returns this peer's IP address.
   */
  public String getIp() {
<span class="fc" id="L154">    return this.address.getAddress().getHostAddress();</span>
  }

  /**
   * Returns this peer's InetAddress.
   */
  public InetSocketAddress getAddress() {
<span class="fc" id="L161">    return this.address;</span>
  }

  /**
   * Returns this peer's port number.
   */
  public int getPort() {
<span class="fc" id="L168">    return this.address.getPort();</span>
  }

  /**
   * Returns this peer's host identifier (&quot;host:port&quot;).
   */
  public String getHostIdentifier() {
<span class="fc" id="L175">    return this.hostId;</span>
  }

  /**
   * Returns a binary representation of the peer's IP.
   */
  public byte[] getRawIp() {
<span class="fc" id="L182">    final InetAddress address = this.address.getAddress();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (address == null) return null;</span>
<span class="fc" id="L184">    return address.getAddress();</span>
  }


  /**
   * Tells if two peers seem to look alike (i.e. they have the same IP, port
   * and peer ID if they have one).
   */
  public boolean looksLike(Peer other) {
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">    if (other == null) {</span>
<span class="nc" id="L194">      return false;</span>
    }

<span class="pc bpc" id="L197" title="1 of 4 branches missed.">    return this.hostId.equals(other.hostId) &amp;&amp; this.getPort() == other.getPort();</span>
  }

  public void setTorrentHash(String hexInfoHash) {
<span class="fc" id="L201">    this.hexInfoHash = hexInfoHash;</span>
<span class="fc" id="L202">  }</span>

  public String getHexInfoHash() {
<span class="fc" id="L205">    return hexInfoHash;</span>
  }

  @Override
  public boolean equals(Object o) {
<span class="fc bfc" id="L210" title="All 2 branches covered.">    if (this == o) return true;</span>
<span class="pc bpc" id="L211" title="2 of 4 branches missed.">    if (o == null || getClass() != o.getClass()) return false;</span>

<span class="fc" id="L213">    Peer peer = (Peer) o;</span>

<span class="pc bpc" id="L215" title="3 of 4 branches missed.">    if (hexPeerId == null &amp;&amp; peer.hexPeerId == null) return super.equals(o);</span>

<span class="pc bpc" id="L217" title="3 of 6 branches missed.">    if (hexPeerId != null ? !hexPeerId.equals(peer.hexPeerId) : peer.hexPeerId != null) return false;</span>
<span class="pc bpc" id="L218" title="3 of 4 branches missed.">    return hexInfoHash != null ? hexInfoHash.equals(peer.hexInfoHash) : peer.hexInfoHash == null;</span>
  }

  @Override
  public int hashCode() {

<span class="pc bpc" id="L224" title="1 of 2 branches missed.">    if (hexPeerId == null) return super.hashCode();</span>

<span class="pc bpc" id="L226" title="1 of 2 branches missed.">    int result = hexPeerId != null ? hexPeerId.hashCode() : 0;</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">    result = 31 * result + (hexInfoHash != null ? hexInfoHash.hashCode() : 0);</span>
<span class="fc" id="L228">    return result;</span>
  }

  /**
   * Returns a human-readable representation of this peer.
   */
  @Override
  public String toString() {
<span class="fc" id="L236">    return &quot;Peer &quot; + address + &quot; for torrent &quot; + hexInfoHash;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>