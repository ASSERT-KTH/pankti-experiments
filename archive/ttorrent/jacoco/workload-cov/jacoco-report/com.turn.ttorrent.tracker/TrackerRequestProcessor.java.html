<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TrackerRequestProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">com.turn.ttorrent.tracker</a> &gt; <span class="el_source">TrackerRequestProcessor.java</span></div><h1>TrackerRequestProcessor.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2011-2012 Turn, Inc.
 * &lt;p&gt;
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * &lt;p&gt;
 * http://www.apache.org/licenses/LICENSE-2.0
 * &lt;p&gt;
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.turn.ttorrent.tracker;

import com.turn.ttorrent.Constants;
import com.turn.ttorrent.bcodec.BEValue;
import com.turn.ttorrent.common.LoggerUtils;
import com.turn.ttorrent.common.Peer;
import com.turn.ttorrent.common.TorrentLoggerFactory;
import com.turn.ttorrent.common.protocol.AnnounceRequestMessage;
import com.turn.ttorrent.common.protocol.TrackerMessage.ErrorMessage;
import com.turn.ttorrent.common.protocol.TrackerMessage.MessageValidationException;
import com.turn.ttorrent.common.protocol.http.HTTPAnnounceRequestMessage;
import com.turn.ttorrent.common.protocol.http.HTTPAnnounceResponseMessage;
import com.turn.ttorrent.common.protocol.http.HTTPTrackerErrorMessage;
import org.simpleframework.http.Status;
import org.slf4j.Logger;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.ByteBuffer;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;


/**
 * Tracker service to serve the tracker's announce requests.
 * &lt;p&gt;
 * &lt;p&gt;
 * It only serves announce requests on /announce, and only serves torrents the
 * {@link Tracker} it serves knows about.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * The list of torrents {@see #requestHandler.getTorrentsMap()} is a map of torrent hashes to their
 * corresponding Torrent objects, and is maintained by the {@link Tracker} this
 * service is part of. The TrackerRequestProcessor only has a reference to this map, and
 * does not modify it.
 * &lt;/p&gt;
 *
 * @author mpetazzoni
 * @see &lt;a href=&quot;http://wiki.theory.org/BitTorrentSpecification&quot;&gt;BitTorrent protocol specification&lt;/a&gt;
 */
public class TrackerRequestProcessor {

<span class="nc" id="L61">  private static final Logger logger =</span>
<span class="nc" id="L62">          TorrentLoggerFactory.getLogger(TrackerRequestProcessor.class);</span>

  /**
   * The list of announce request URL fields that need to be interpreted as
   * numeric and thus converted as such in the request message parsing.
   */
<span class="nc" id="L68">  private static final String[] NUMERIC_REQUEST_FIELDS =</span>
          new String[]{
                  &quot;port&quot;, &quot;uploaded&quot;, &quot;downloaded&quot;, &quot;left&quot;,
                  &quot;compact&quot;, &quot;no_peer_id&quot;, &quot;numwant&quot;
          };
  private static final int SEEDER_ANNOUNCE_INTERVAL = 150;

<span class="nc" id="L75">  private boolean myAcceptForeignTorrents = true; //default to true</span>
<span class="nc" id="L76">  private int myAnnounceInterval = 60; //default value</span>
  private final AddressChecker myAddressChecker;
  private final TorrentsRepository myTorrentsRepository;


  /**
   * Create a new TrackerRequestProcessor serving the given torrents.
   */
  public TrackerRequestProcessor(TorrentsRepository torrentsRepository) {
<span class="nc" id="L85">    this(torrentsRepository, new AddressChecker() {</span>
      @Override
      public boolean isBadAddress(String ip) {
<span class="nc" id="L88">        return false;</span>
      }
    });
<span class="nc" id="L91">  }</span>

<span class="nc" id="L93">  public TrackerRequestProcessor(TorrentsRepository torrentsRepository, AddressChecker addressChecker) {</span>
<span class="nc" id="L94">    myTorrentsRepository = torrentsRepository;</span>
<span class="nc" id="L95">    myAddressChecker = addressChecker;</span>
<span class="nc" id="L96">  }</span>

  /**
   * Process the announce request.
   * &lt;p&gt;
   * &lt;p&gt;
   * This method attemps to read and parse the incoming announce request into
   * an announce request message, then creates the appropriate announce
   * response message and sends it back to the client.
   * &lt;/p&gt;
   */
  public void process(final String uri, final String hostAddress, RequestHandler requestHandler)
          throws IOException {
    // Prepare the response headers.

    /**
     * Parse the query parameters into an announce request message.
     *
     * We need to rely on our own query parsing function because
     * SimpleHTTP's Query map will contain UTF-8 decoded parameters, which
     * doesn't work well for the byte-encoded strings we expect.
     */
    HTTPAnnounceRequestMessage announceRequest;
    try {
<span class="nc" id="L120">      announceRequest = this.parseQuery(uri, hostAddress);</span>
<span class="nc" id="L121">    } catch (MessageValidationException mve) {</span>
<span class="nc" id="L122">      LoggerUtils.warnAndDebugDetails(logger, &quot;Unable to parse request message. Request url is {}&quot;, uri, mve);</span>
<span class="nc" id="L123">      serveError(Status.BAD_REQUEST, mve.getMessage(), requestHandler);</span>
<span class="nc" id="L124">      return;</span>
<span class="nc" id="L125">    }</span>

<span class="nc" id="L127">    AnnounceRequestMessage.RequestEvent event = announceRequest.getEvent();</span>

<span class="nc bnc" id="L129" title="All 2 branches missed.">    if (event == null) {</span>
<span class="nc" id="L130">      event = AnnounceRequestMessage.RequestEvent.NONE;</span>
    }
<span class="nc" id="L132">    TrackedTorrent torrent = myTorrentsRepository.getTorrent(announceRequest.getHexInfoHash());</span>

    // The requested torrent must be announced by the tracker if and only if myAcceptForeignTorrents is false
<span class="nc bnc" id="L135" title="All 4 branches missed.">    if (!myAcceptForeignTorrents &amp;&amp; torrent == null) {</span>
<span class="nc" id="L136">      logger.warn(&quot;Requested torrent hash was: {}&quot;, announceRequest.getHexInfoHash());</span>
<span class="nc" id="L137">      serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.UNKNOWN_TORRENT, requestHandler);</span>
<span class="nc" id="L138">      return;</span>
    }

<span class="nc bnc" id="L141" title="All 2 branches missed.">    final boolean isSeeder = (event == AnnounceRequestMessage.RequestEvent.COMPLETED)</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">            || (announceRequest.getLeft() == 0);</span>

<span class="nc bnc" id="L144" title="All 2 branches missed.">    if (myAddressChecker.isBadAddress(announceRequest.getIp())) {</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">      if (torrent == null) {</span>
<span class="nc" id="L146">        writeEmptyResponse(announceRequest, requestHandler);</span>
      } else {
<span class="nc" id="L148">        writeAnnounceResponse(torrent, null, isSeeder, requestHandler);</span>
      }
<span class="nc" id="L150">      return;</span>
    }

<span class="nc" id="L153">    final Peer peer = new Peer(announceRequest.getIp(), announceRequest.getPort());</span>

    try {
<span class="nc" id="L156">      torrent = myTorrentsRepository.putIfAbsentAndUpdate(announceRequest.getHexInfoHash(),</span>
<span class="nc" id="L157">              new TrackedTorrent(announceRequest.getInfoHash()),</span>
              event,
<span class="nc" id="L159">              ByteBuffer.wrap(announceRequest.getPeerId()),</span>
<span class="nc" id="L160">              announceRequest.getHexPeerId(),</span>
<span class="nc" id="L161">              announceRequest.getIp(),</span>
<span class="nc" id="L162">              announceRequest.getPort(),</span>
<span class="nc" id="L163">              announceRequest.getUploaded(),</span>
<span class="nc" id="L164">              announceRequest.getDownloaded(),</span>
<span class="nc" id="L165">              announceRequest.getLeft());</span>
<span class="nc" id="L166">    } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L167">      LoggerUtils.warnAndDebugDetails(logger, &quot;Unable to update peer torrent. Request url is {}&quot;, uri, iae);</span>
<span class="nc" id="L168">      serveError(Status.BAD_REQUEST, ErrorMessage.FailureReason.INVALID_EVENT, requestHandler);</span>
<span class="nc" id="L169">      return;</span>
<span class="nc" id="L170">    }</span>

    // Craft and output the answer
<span class="nc" id="L173">    writeAnnounceResponse(torrent, peer, isSeeder, requestHandler);</span>
<span class="nc" id="L174">  }</span>

  private void writeEmptyResponse(HTTPAnnounceRequestMessage announceRequest, RequestHandler requestHandler) throws IOException {
    HTTPAnnounceResponseMessage announceResponse;
    try {
<span class="nc" id="L179">      announceResponse = HTTPAnnounceResponseMessage.craft(</span>
              myAnnounceInterval,
              0,
              0,
<span class="nc" id="L183">              Collections.&lt;Peer&gt;emptyList(),</span>
<span class="nc" id="L184">              announceRequest.getHexInfoHash());</span>
<span class="nc" id="L185">      requestHandler.serveResponse(Status.OK.getCode(), Status.OK.getDescription(), announceResponse.getData());</span>
<span class="nc" id="L186">    } catch (Exception e) {</span>
<span class="nc" id="L187">      serveError(Status.INTERNAL_SERVER_ERROR, e.getMessage(), requestHandler);</span>
<span class="nc" id="L188">    }</span>
<span class="nc" id="L189">  }</span>

  public void setAnnounceInterval(int announceInterval) {
<span class="nc" id="L192">    myAnnounceInterval = announceInterval;</span>
<span class="nc" id="L193">  }</span>

  public int getAnnounceInterval() {
<span class="nc" id="L196">    return myAnnounceInterval;</span>
  }

  private void writeAnnounceResponse(TrackedTorrent torrent, Peer peer, boolean isSeeder, RequestHandler requestHandler) throws IOException {
    HTTPAnnounceResponseMessage announceResponse;
    try {
<span class="nc bnc" id="L202" title="All 2 branches missed.">      announceResponse = HTTPAnnounceResponseMessage.craft(</span>
              isSeeder ? SEEDER_ANNOUNCE_INTERVAL : myAnnounceInterval,
<span class="nc" id="L204">              torrent.seeders(),</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">              torrent.leechers(),</span>
<span class="nc" id="L206">              isSeeder ? Collections.&lt;Peer&gt;emptyList() : torrent.getSomePeers(peer),</span>
<span class="nc" id="L207">              torrent.getHexInfoHash());</span>
<span class="nc" id="L208">      requestHandler.serveResponse(Status.OK.getCode(), Status.OK.getDescription(), announceResponse.getData());</span>
<span class="nc" id="L209">    } catch (Exception e) {</span>
<span class="nc" id="L210">      serveError(Status.INTERNAL_SERVER_ERROR, e.getMessage(), requestHandler);</span>
<span class="nc" id="L211">    }</span>
<span class="nc" id="L212">  }</span>

  /**
   * Parse the query parameters using our defined BYTE_ENCODING.
   * &lt;p&gt;
   * &lt;p&gt;
   * Because we're expecting byte-encoded strings as query parameters, we
   * can't rely on SimpleHTTP's QueryParser which uses the wrong encoding for
   * the job and returns us unparsable byte data. We thus have to implement
   * our own little parsing method that uses BYTE_ENCODING to decode
   * parameters from the URI.
   * &lt;/p&gt;
   * &lt;p&gt;
   * &lt;p&gt;
   * &lt;b&gt;Note:&lt;/b&gt; array parameters are not supported. If a key is present
   * multiple times in the URI, the latest value prevails. We don't really
   * need to implement this functionality as this never happens in the
   * Tracker HTTP protocol.
   * &lt;/p&gt;
   *
   * @param uri
   * @param hostAddress
   * @return The {@link AnnounceRequestMessage} representing the client's
   * announce request.
   */
  private HTTPAnnounceRequestMessage parseQuery(final String uri, final String hostAddress)
          throws IOException, MessageValidationException {
<span class="nc" id="L239">    Map&lt;String, BEValue&gt; params = new HashMap&lt;String, BEValue&gt;();</span>

    try {
//			String uri = request.getAddress().toString();
<span class="nc bnc" id="L243" title="All 2 branches missed.">      for (String pair : uri.split(&quot;[?]&quot;)[1].split(&quot;&amp;&quot;)) {</span>
<span class="nc" id="L244">        String[] keyval = pair.split(&quot;[=]&quot;, 2);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (keyval.length == 1) {</span>
<span class="nc" id="L246">          this.recordParam(params, keyval[0], null);</span>
        } else {
<span class="nc" id="L248">          this.recordParam(params, keyval[0], keyval[1]);</span>
        }
      }
<span class="nc" id="L251">    } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L252">      params.clear();</span>
<span class="nc" id="L253">    }</span>

    // Make sure we have the peer IP, fallbacking on the request's source
    // address if the peer didn't provide it.
<span class="nc bnc" id="L257" title="All 2 branches missed.">    if (params.get(&quot;ip&quot;) == null) {</span>
<span class="nc" id="L258">      params.put(&quot;ip&quot;, new BEValue(</span>
              hostAddress,
              Constants.BYTE_ENCODING));
    }

<span class="nc" id="L263">    return HTTPAnnounceRequestMessage.parse(new BEValue(params));</span>
  }

  private void recordParam(Map&lt;String, BEValue&gt; params, String key, String value) {
    try {
<span class="nc" id="L268">      value = URLDecoder.decode(value, Constants.BYTE_ENCODING);</span>

<span class="nc bnc" id="L270" title="All 2 branches missed.">      for (String f : NUMERIC_REQUEST_FIELDS) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (f.equals(key)) {</span>
<span class="nc" id="L272">          params.put(key, new BEValue(Long.valueOf(value)));</span>
<span class="nc" id="L273">          return;</span>
        }
      }

<span class="nc" id="L277">      params.put(key, new BEValue(value, Constants.BYTE_ENCODING));</span>
<span class="nc" id="L278">    } catch (UnsupportedEncodingException uee) {</span>
      // Ignore, act like parameter was not there
<span class="nc" id="L280">    }</span>
<span class="nc" id="L281">  }</span>

  /**
   * Write a {@link HTTPTrackerErrorMessage} to the response with the given
   * HTTP status code.
   *
   * @param status The HTTP status code to return.
   * @param error  The error reported by the tracker.
   */
  private void serveError(Status status, HTTPTrackerErrorMessage error, RequestHandler requestHandler) throws IOException {
<span class="nc" id="L291">    requestHandler.serveResponse(status.getCode(), status.getDescription(), error.getData());</span>
<span class="nc" id="L292">  }</span>

  /**
   * Write an error message to the response with the given HTTP status code.
   *
   * @param status The HTTP status code to return.
   * @param error  The error message reported by the tracker.
   */
  private void serveError(Status status, String error, RequestHandler requestHandler) throws IOException {
<span class="nc" id="L301">    this.serveError(status, HTTPTrackerErrorMessage.craft(error), requestHandler);</span>
<span class="nc" id="L302">  }</span>

  /**
   * Write a tracker failure reason code to the response with the given HTTP
   * status code.
   *
   * @param status The HTTP status code to return.
   * @param reason The failure reason reported by the tracker.
   */
  private void serveError(Status status, ErrorMessage.FailureReason reason, RequestHandler requestHandler) throws IOException {
<span class="nc" id="L312">    this.serveError(status, reason.getMessage(), requestHandler);</span>
<span class="nc" id="L313">  }</span>

  public void setAcceptForeignTorrents(boolean acceptForeignTorrents) {
<span class="nc" id="L316">    myAcceptForeignTorrents = acceptForeignTorrents;</span>
<span class="nc" id="L317">  }</span>

  public interface RequestHandler {
    void serveResponse(int code, String description, ByteBuffer responseData);
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>